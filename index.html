import React, { useState, useEffect, useRef } from 'react';
import { Trash2, PlayCircle, Settings, RefreshCw, GitBranch, Plus, Minus, X, Code, Cpu, Save, List, Type, Check, Terminal, Play, MoreHorizontal, ArrowRight, MousePointer2, Lock } from 'lucide-react';

// --- å®šç¾©ç©æœ¨å½¢ç‹€é¡å‹ ---
const SHAPES = {
  HAT: 'HAT',       // å¸½å­ (äº‹ä»¶) - ä¸Šé¢å¹³çš„ï¼Œä¸‹é¢æœ‰å‡¸
  STACK: 'STACK',   // å †ç–Š (ä¸€èˆ¬æŒ‡ä»¤) - ä¸Šå‡¹ä¸‹å‡¸
  C_BLOCK: 'C',     // Cå‹ (è¿´åœˆ/é‚è¼¯) - åŒ…è£¹å…¶ä»–ç©æœ¨
  CAP: 'CAP',       // å¸½å­ (çµæŸ) - ä¸Šå‡¹ä¸‹é¢å¹³
  REPORTER: 'VAL',  // æ©¢åœ“ (æ•¸å€¼/å­—ä¸²) - ( )
  BOOLEAN: 'BOOL'   // å…­è§’ (é‚è¼¯åˆ¤æ–·) - < >
};

// --- ç©æœ¨å®šç¾©åº« ---
const BLOCK_DEFS = {
  // --- äº‹ä»¶ (Event) ğŸŸ¡ ---
  SETUP: { type: 'SETUP', cat: 'EVENT', name: 'ç•¶ Arduino é–‹å•Ÿ', shape: SHAPES.HAT, code: '// Setup' },
  
  // --- æ§åˆ¶ (Control) ğŸŸ§ ---
  // [ä¿®æ”¹] æ”¹ç‚ºæ¯«ç§’ï¼Œé è¨­å€¼æ”¹ç‚º 1000
  WAIT: { type: 'WAIT', cat: 'CONTROL', name: 'ç­‰å¾… ( time ) æ¯«ç§’', args: [{type: 'NUM', default: 1000}], shape: SHAPES.STACK },
  WAIT_UNTIL: { type: 'WAIT_UNTIL', cat: 'CONTROL', name: 'ç­‰å¾…ç›´åˆ° < cond >', args: [{type: 'BOOL', default: false}], shape: SHAPES.STACK },

  // --- è¿´åœˆ (Loop) ğŸŸ¢ ---
  REPEAT: { type: 'REPEAT', cat: 'LOOP', name: 'é‡è¤‡ ( times ) æ¬¡', args: [{type: 'NUM', default: 10}], shape: SHAPES.C_BLOCK },
  FOREVER: { type: 'FOREVER', cat: 'LOOP', name: 'é‡è¤‡ç„¡é™æ¬¡', shape: SHAPES.C_BLOCK, isLoop: true },
  REPEAT_UNTIL: { type: 'REPEAT_UNTIL', cat: 'LOOP', name: 'é‡è¤‡ç›´åˆ° < cond >', args: [{type: 'BOOL', default: false}], shape: SHAPES.C_BLOCK },

  // --- é‚è¼¯ (Logic) ğŸ”µ ---
  IF: { type: 'IF', cat: 'LOGIC', name: 'å¦‚æœ < cond > é‚£éº¼', args: [{type: 'BOOL', default: false}], shape: SHAPES.C_BLOCK },
  IF_ELSE: { type: 'IF_ELSE', cat: 'LOGIC', name: 'å¦‚æœ < cond > é‚£éº¼...å¦å‰‡', args: [{type: 'BOOL', default: false}], shape: SHAPES.C_BLOCK, hasElse: true },
  
  // --- é‹ç®—ç¬¦ (Logic Ops) ğŸ”µ ---
  COMPARE: { type: 'COMPARE', cat: 'LOGIC', name: '( a ) * op * ( b )', args: [{type: 'NUM', default: 0}, {type: 'MENU', options: ['==','!=','>','<','>=','<=']}, {type: 'NUM', default: 0}], shape: SHAPES.BOOLEAN },
  AND_OR: { type: 'AND_OR', cat: 'LOGIC', name: '< a > * op * < b >', args: [{type: 'BOOL', default: false}, {type: 'MENU', options: ['&&','||']}, {type: 'BOOL', default: false}], shape: SHAPES.BOOLEAN },
  NOT: { type: 'NOT', cat: 'LOGIC', name: 'ä¸æˆç«‹ < bool >', args: [{type: 'BOOL', default: false}], shape: SHAPES.BOOLEAN },

  // --- æ•¸å­¸ (Math) â• ---
  NUMBER: { type: 'NUMBER', cat: 'MATH', name: '( val )', args: [{type: 'NUM', default: 0}], shape: SHAPES.REPORTER },
  MATH_OP: { type: 'MATH_OP', cat: 'MATH', name: '( a ) * op * ( b )', args: [{type: 'NUM', default: 0}, {type: 'MENU', options: ['+','-','*','/']}, {type: 'NUM', default: 0}], shape: SHAPES.REPORTER },
  RANDOM: { type: 'RANDOM', cat: 'MATH', name: 'éš¨æ©Ÿå–æ•¸ ( min ) åˆ° ( max )', args: [{type: 'NUM', default: 1}, {type: 'NUM', default: 10}], shape: SHAPES.REPORTER },
  MOD: { type: 'MOD', cat: 'MATH', name: '( a ) é™¤ä»¥ ( b ) çš„é¤˜æ•¸', args: [{type: 'NUM', default: 10}, {type: 'NUM', default: 2}], shape: SHAPES.REPORTER },
  MATH_FUNC: { type: 'MATH_FUNC', cat: 'MATH', name: '* func * æ•¸å€¼ ( val )', args: [{type: 'MENU', options: ['abs', 'round', 'ceil', 'floor', 'sqrt', 'sin', 'cos']}, {type: 'NUM', default: 0}], shape: SHAPES.REPORTER },

  // --- IO æ“´å…… (ç¯„ä¾‹) ---
  LED_SET: { type: 'LED_SET', cat: 'IO', name: 'D ( pin ) LED - * status *', args: [{type: 'NUM', default: 13}, {type: 'MENU', options: ['äº®', 'æ»…']}], shape: SHAPES.STACK },
  
  // --- è®Šæ•¸ (Variable) ğŸ”¶ ---
  // å‹•æ…‹ç”Ÿæˆ

  // --- æ¸…å–® (List) ğŸ”´ ---
  LIST_ADD: { type: 'LIST_ADD', cat: 'LIST', name: 'æ·»åŠ  ( item ) åˆ° * list *', args: [{type: 'NUM', default: 0}, {type: 'LIST_MENU'}], shape: SHAPES.STACK },
  LIST_DEL_IDX: { type: 'LIST_DEL_IDX', cat: 'LIST', name: 'åˆªé™¤ * list * çš„ç¬¬ ( idx ) é …', args: [{type: 'LIST_MENU'}, {type: 'NUM', default: 0}], shape: SHAPES.STACK },
  LIST_DEL_ALL: { type: 'LIST_DEL_ALL', cat: 'LIST', name: 'åˆªé™¤ * list * çš„æ‰€æœ‰é …ç›®', args: [{type: 'LIST_MENU'}], shape: SHAPES.STACK },
  LIST_INSERT: { type: 'LIST_INSERT', cat: 'LIST', name: 'æ’å…¥ ( val ) åˆ° * list * çš„ç¬¬ ( idx ) é …', args: [{type: 'NUM', default: 0}, {type: 'LIST_MENU'}, {type: 'NUM', default: 0}], shape: SHAPES.STACK },
  LIST_REPLACE: { type: 'LIST_REPLACE', cat: 'LIST', name: 'æ›¿æ› * list * çš„ç¬¬ ( idx ) é …ç‚º ( val )', args: [{type: 'LIST_MENU'}, {type: 'NUM', default: 0}, {type: 'NUM', default: 0}], shape: SHAPES.STACK },
  // Reporters
  LIST_ITEM: { type: 'LIST_ITEM', cat: 'LIST', name: '* list * çš„ç¬¬ ( idx ) é …', args: [{type: 'LIST_MENU'}, {type: 'NUM', default: 0}], shape: SHAPES.REPORTER },
  LIST_INDEX: { type: 'LIST_INDEX', cat: 'LIST', name: '( val ) åœ¨ * list * è£¡çš„é …ç›®ç·¨è™Ÿ', args: [{type: 'NUM', default: 0}, {type: 'LIST_MENU'}], shape: SHAPES.REPORTER },
  LIST_LEN: { type: 'LIST_LEN', cat: 'LIST', name: 'æ¸…å–® * list * çš„é•·åº¦', args: [{type: 'LIST_MENU'}], shape: SHAPES.REPORTER },
  LIST_CONTAINS: { type: 'LIST_CONTAINS', cat: 'LIST', name: 'æ¸…å–® * list * åŒ…å« ( val ) ?', args: [{type: 'LIST_MENU'}, {type: 'NUM', default: 0}], shape: SHAPES.BOOLEAN },
};

const CATEGORIES = {
  EVENT: { name: 'äº‹ä»¶', color: 'bg-yellow-500', icon: <PlayCircle size={14}/> },
  CONTROL: { name: 'æ§åˆ¶', color: 'bg-orange-500', icon: <Settings size={14}/> },
  LOOP: { name: 'è¿´åœˆ', color: 'bg-green-500', icon: <RefreshCw size={14}/> },
  LOGIC: { name: 'é‚è¼¯', color: 'bg-blue-500', icon: <GitBranch size={14}/> },
  MATH: { name: 'é‹ç®—', color: 'bg-green-400', icon: <Plus size={14}/> },
  VAR: { name: 'è®Šæ•¸', color: 'bg-orange-400', icon: <Type size={14}/> },
  LIST: { name: 'æ¸…å–®', color: 'bg-red-500', icon: <List size={14}/> },
  IO: { name: 'ç¡¬é«”', color: 'bg-purple-500', icon: <Cpu size={14}/> },
};

const uid = () => Math.random().toString(36).substr(2, 9);

// é è¨­è…³æœ¬ (åŒ…å«ä¸€å€‹ç„¡æ³•åˆªé™¤çš„ SETUP ç©æœ¨)
const INITIAL_SCRIPT = [
  { id: 'root-setup-block', type: 'SETUP', args: [], children: [], elseChildren: [] }
];

export default function ArduinoBlockBuilder() {
  const [script, setScript] = useState(INITIAL_SCRIPT);
  const [variables, setVariables] = useState([]);
  const [lists, setLists] = useState([]);
  
  // DnD State
  const dragItem = useRef(null); // { type: 'NEW' | 'MOVE', defKey, data, id (if move) }
  const [dragOverId, setDragOverId] = useState(null); // ç”¨æ–¼è¦–è¦ºåé¥‹

  // Modal State
  const [showVarModal, setShowVarModal] = useState(false);
  const [showListModal, setShowListModal] = useState(false);
  const [newItemName, setNewItemName] = useState('');

  // --- æ‹–æ›³é‚è¼¯ ---
  const handleDragStart = (e, type, payload) => {
    // é˜²æ­¢ SETUP ç©æœ¨è¢«æ‹–æ›³
    if (payload.type === 'SETUP') {
        e.preventDefault();
        return;
    }
    e.stopPropagation();
    // type: 'NEW' (å¾å·¥å…·ç®±), 'MOVE' (å¾å·¥ä½œå€)
    dragItem.current = { type, ...payload };
    e.dataTransfer.effectAllowed = 'copyMove';
    e.dataTransfer.setData('application/json', JSON.stringify({ type, ...payload }));
  };

  const handleDragOver = (e, targetId, type) => {
    e.preventDefault();
    e.stopPropagation();
    setDragOverId(targetId); 
  };

  const handleDrop = (e, targetId, targetType, extraInfo = {}) => {
    e.preventDefault();
    e.stopPropagation();
    setDragOverId(null);

    const item = dragItem.current;
    if (!item) return;

    // 1. åƒåœ¾æ¡¶é‚è¼¯
    if (targetType === 'TRASH') {
        if (item.type === 'MOVE') {
             // å†æ¬¡ç¢ºä¿ä¸èƒ½åˆªé™¤ SETUP
             const blockToDelete = findBlockById(script, item.id);
             if (blockToDelete && blockToDelete.type !== 'SETUP') {
                 deleteBlock(item.id);
             }
        }
        return;
    }

    // 2. æº–å‚™ç©æœ¨è³‡æ–™
    let newBlock;
    if (item.type === 'NEW') {
        const def = BLOCK_DEFS[item.defKey] || item.data;
        newBlock = {
            id: uid(),
            type: item.defKey,
            args: def.args ? def.args.map(a => a.default) : [],
            children: [],
            elseChildren: [],
            ...item.data
        };
    } else {
        // MOVE: 
        if (containsId(item.id, targetId)) return; // é˜²æ­¢çˆ¶ç§»å­
        
        const found = findBlockById(script, item.id);
        if (!found) return;
        // å†æ¬¡ç¢ºä¿ä¸èƒ½ç§»å‹• SETUP
        if (found.type === 'SETUP') return;

        newBlock = { ...found, id: uid() }; 
    }

    // 3. åŸ·è¡Œæ”¾ç½®
    if (targetType === 'ROOT') {
        setScript(prev => [...prev, newBlock]);
    } else if (targetType === 'CONTAINER') {
        addBlockToContainer(targetId, extraInfo.subType || 'children', newBlock);
    } else if (targetType === 'SLOT') {
        const def = BLOCK_DEFS[newBlock.type] || newBlock;
        const slotType = extraInfo.slotType;
        const blockShape = def.shape;
        
        let compatible = false;
        if (slotType === 'NUM' && blockShape === SHAPES.REPORTER) compatible = true;
        if (slotType === 'BOOL' && blockShape === SHAPES.BOOLEAN) compatible = true;
        if (slotType === 'ANY' && blockShape === SHAPES.REPORTER) compatible = true;

        if (compatible) {
             insertBlockIntoSlot(targetId, extraInfo.argIndex, newBlock);
        } else {
            return;
        }
    }

    // 4. å¦‚æœæ˜¯ç§»å‹•ï¼Œåˆªé™¤èˆŠçš„
    if (item.type === 'MOVE') {
        deleteBlock(item.id);
    }
  };

  // --- è¼”åŠ©å‡½å¼ ---
  const findBlockById = (list, id) => {
      for (let b of list) {
          if (b.id === id) return b;
          if (b.children) {
              const found = findBlockById(b.children, id);
              if (found) return found;
          }
          if (b.elseChildren) {
              const found = findBlockById(b.elseChildren, id);
              if (found) return found;
          }
          if (b.args) {
             for (let arg of b.args) {
                 if (typeof arg === 'object' && arg.id) {
                     const found = findBlockById([arg], id);
                     if (found) return found;
                 }
             }
          }
      }
      return null;
  };

  const containsId = (parentId, childId) => {
      return parentId === childId; 
  };

  const deleteBlock = (id) => {
    const deleteRecursive = (blocks) => {
      return blocks.filter(b => b.id !== id).map(b => {
        let newB = { ...b };
        if (b.children) newB.children = deleteRecursive(b.children);
        if (b.elseChildren) newB.elseChildren = deleteRecursive(b.elseChildren);
        if (b.args) {
            newB.args = b.args.map(arg => {
                if (typeof arg === 'object' && arg.id) {
                    if (arg.id === id) {
                         return 0; 
                    }
                    return arg;
                }
                return arg;
            });
        }
        return newB;
      });
    };
    setScript(prev => deleteRecursive(prev));
  };

  const addBlockToContainer = (targetId, subType, newBlock) => {
      const update = (list) => {
          return list.map(b => {
              if (b.id === targetId) {
                  if (subType === 'else') {
                      return { ...b, elseChildren: [...(b.elseChildren||[]), newBlock] };
                  } else {
                      return { ...b, children: [...(b.children||[]), newBlock] };
                  }
              }
              let newB = { ...b };
              if (b.children) newB.children = update(b.children);
              if (b.elseChildren) newB.elseChildren = update(b.elseChildren);
              return newB;
          });
      };
      setScript(prev => update(prev));
  };

  const insertBlockIntoSlot = (targetId, argIndex, newBlock) => {
    const updateRecursive = (blocks) => {
      return blocks.map(b => {
        if (b.id === targetId) {
          const newArgs = [...b.args];
          newArgs[argIndex] = newBlock;
          return { ...b, args: newArgs };
        }
        let updatedB = { ...b };
        if (b.children) updatedB.children = updateRecursive(b.children);
        if (b.elseChildren) updatedB.elseChildren = updateRecursive(b.elseChildren);
        if (b.args) {
            updatedB.args = b.args.map(arg => {
                if (typeof arg === 'object' && arg.id) {
                     // No deep recursion needed for V3.1 flat logic
                }
                return arg;
            });
        }
        return updatedB;
      });
    };
    setScript(prev => updateRecursive(prev));
  };
  
  const updateBlockArg = (blockId, argIdx, val) => {
    const update = (list) => {
      return list.map(b => {
        if (b.id === blockId) {
          const newArgs = [...b.args];
          newArgs[argIdx] = val;
          return { ...b, args: newArgs };
        }
        let newB = { ...b };
        if (b.children) newB.children = update(b.children);
        if (b.elseChildren) newB.elseChildren = update(b.elseChildren);
        return newB;
      });
    };
    setScript(prev => update(prev));
  };

  const createVariable = () => {
    if (!newItemName) return;
    setVariables([...variables, newItemName]);
    setNewItemName('');
    setShowVarModal(false);
  };
  const createList = () => {
    if (!newItemName) return;
    setLists([...lists, newItemName]);
    setNewItemName('');
    setShowListModal(false);
  };

  // --- ä»£ç¢¼ç”Ÿæˆ ---
  const generateCode = () => {
    let globalVars = '';
    let setupCode = '';
    let loopCode = '';
    let functions = '';

    variables.forEach(v => { globalVars += `float ${v} = 0;\n`; });
    lists.forEach(l => {
      globalVars += `float ${l}[100];\nint ${l}_len = 0;\n`;
    });
    if (lists.length > 0) {
        functions += `void list_add(float* list, int* len, float val) { if (*len < 100) { list[*len] = val; (*len)++; } }\n`;
        functions += `void list_del_idx(float* list, int* len, int idx) { if (idx >= 0 && idx < *len) { for (int i = idx; i < *len - 1; i++) { list[i] = list[i+1]; } (*len)--; } }\n`;
        functions += `void list_del_all(int* len) { *len = 0; }\n`;
    }

    const parseBlock = (block) => {
      const args = (block.args || []).map(arg => {
        if (typeof arg === 'object' && arg.id) return parseBlock(arg);
        return arg;
      });

      switch (block.type) {
        case 'SETUP': return '';
        // [ä¿®æ”¹] ä»£ç¢¼ç”Ÿæˆï¼šç§»é™¤ * 1000
        case 'WAIT': return `delay(${args[0]});\n`;
        case 'WAIT_UNTIL': return `while(!(${args[0]})) { delay(10); }\n`;
        case 'FOREVER': return `// Loop logic handled by loop()\n${parseChildren(block.children)}`;
        case 'REPEAT': return `for(int i=0; i<${args[0]}; i++) {\n${parseChildren(block.children)}}\n`;
        case 'REPEAT_UNTIL': return `while(!(${args[0]})) {\n${parseChildren(block.children)}}\n`;
        case 'IF': return `if (${args[0]}) {\n${parseChildren(block.children)}}\n`;
        case 'IF_ELSE': return `if (${args[0]}) {\n${parseChildren(block.children)}} else {\n${parseChildren(block.elseChildren)}}\n`;
        case 'NUMBER': return `${args[0]}`;
        case 'COMPARE': return `(${args[0]} ${args[1]} ${args[2]})`;
        case 'AND_OR': return `(${args[0]} ${args[1]} ${args[2]})`;
        case 'NOT': return `!(${args[0]})`;
        case 'MATH_OP': return `(${args[0]} ${args[1]} ${args[2]})`;
        case 'RANDOM': return `random(${args[0]}, ${args[1]})`;
        case 'MOD': return `((int)${args[0]} % (int)${args[1]})`;
        case 'MATH_FUNC': 
             if (args[0] === 'round') return `round(${args[1]})`;
             if (args[0] === 'abs') return `abs(${args[1]})`;
             return `${args[0]}(${args[1]})`;
        case 'VAR_GET': return `${block.varName}`;
        case 'VAR_SET': return `${args[0]} = ${args[1]};\n`;
        case 'VAR_CHANGE': return `${args[0]} += ${args[1]};\n`;
        case 'LIST_ADD': return `list_add(${args[1]}, &${args[1]}_len, ${args[0]});\n`;
        case 'LIST_DEL_IDX': return `list_del_idx(${args[0]}, &${args[0]}_len, ${args[1]});\n`;
        case 'LIST_DEL_ALL': return `list_del_all(&${args[0]}_len);\n`;
        case 'LIST_ITEM': return `${args[0]}[(int)${args[1]}]`;
        case 'LIST_LEN': return `${args[0]}_len`;
        case 'LED_SET': return `digitalWrite(${args[0]}, ${args[1] === 'äº®' ? 'HIGH' : 'LOW'});\n`;
        default: return `// ${block.type}\n`;
      }
    };

    const parseChildren = (children) => {
      if (!children) return '';
      return children.map(b => parseBlock(b)).join('');
    };

    script.forEach(block => {
      if (block.type === 'FOREVER') loopCode += parseChildren(block.children);
      else if (block.type !== 'SETUP') setupCode += parseBlock(block);
    });
    
    return `${globalVars}\n${functions}\nvoid setup() {\n  Serial.begin(9600);\n${setupCode}}\n\nvoid loop() {\n${loopCode}}`;
  };

  // --- UI å…ƒä»¶ ---
  const BlockRenderer = ({ block, depth = 0 }) => {
    const def = BLOCK_DEFS[block.type] || { ...block, shape: SHAPES.STACK, color: 'bg-gray-500' };
    const cat = CATEGORIES[def.cat] || { color: 'bg-gray-500' };
    const bgColor = def.color || cat.color;
    const isSetup = block.type === 'SETUP'; 
    
    // å½¢ç‹€ CSS
    const shapeClass = {
      [SHAPES.HAT]: 'rounded-t-xl rounded-b-md mt-4 mb-1',
      [SHAPES.CAP]: 'rounded-t-md rounded-b-xl mt-1',
      [SHAPES.STACK]: 'rounded my-1',
      [SHAPES.C_BLOCK]: 'rounded-t rounded-b-lg my-1',
      [SHAPES.REPORTER]: 'rounded-full px-3 py-1 inline-flex items-center mx-1',
      [SHAPES.BOOLEAN]: 'clip-hex px-3 py-1 inline-flex items-center mx-1'
    }[def.shape] || 'rounded';

    // åƒæ•¸æ¸²æŸ“
    const renderArg = (arg, argIdx, uniqueKey) => {
      if (typeof arg === 'object' && arg.id) {
        return (
          <div className="inline-block align-middle relative group/arg" key={uniqueKey}>
             <div 
               draggable 
               onDragStart={(e) => handleDragStart(e, 'MOVE', { id: arg.id, type: arg.type })}
               onClick={(e) => e.stopPropagation()}
             >
                <BlockRenderer block={arg} depth={depth + 1} />
             </div>
          </div>
        );
      }
      
      const argDef = def.args ? def.args[argIdx] : null;
      if (!argDef) return null;

      if (argDef.type === 'MENU' || argDef.type === 'LIST_MENU') {
        const bgClass = argDef.type === 'LIST_MENU' ? 'bg-red-100' : 'bg-white/90';
        const options = argDef.type === 'LIST_MENU' ? (lists.length ? lists : ['ç„¡']) : argDef.options;
        return (
          <select 
            value={arg} 
            onChange={(e) => updateBlockArg(block.id, argIdx, e.target.value)}
            className={`text-black text-xs px-1 py-0.5 rounded mx-1 border-none outline-none cursor-pointer ${bgClass}`}
            onClick={(e) => e.stopPropagation()}
            key={uniqueKey}
          >
            {options.map(opt => <option key={opt} value={opt}>{opt}</option>)}
          </select>
        );
      }

      const isOver = dragOverId === `${block.id}-arg-${argIdx}`;
      const slotClass = isOver ? 'ring-2 ring-yellow-300 bg-yellow-100/50' : 'bg-black/20 hover:bg-black/30';
      const shapeStyle = argDef.type === 'BOOL' ? 'clip-hex px-3' : 'rounded-full px-2';

      return (
        <span 
          key={uniqueKey}
          className={`inline-flex items-center justify-center min-w-[30px] h-[24px] mx-1 text-xs transition-all ${slotClass} ${shapeStyle}`}
          onDragOver={(e) => handleDragOver(e, `${block.id}-arg-${argIdx}`, 'SLOT')}
          onDrop={(e) => handleDrop(e, block.id, 'SLOT', { argIndex: argIdx, slotType: argDef.type })}
        >
          {argDef.type === 'NUM' || argDef.type === 'ANY' ? (
              <input 
                type="text" 
                value={arg}
                onChange={(e) => updateBlockArg(block.id, argIdx, e.target.value)}
                className="bg-transparent text-white text-center w-full outline-none"
                onClick={(e) => e.stopPropagation()} 
                draggable
                onDragStart={(e) => { e.preventDefault(); e.stopPropagation(); }}
              />
          ) : (
             <span className="text-white/50 text-[10px]">{isOver ? 'æ”¾å…¥' : '< >'}</span>
          )}
        </span>
      );
    };

    const renderTitle = () => {
      const parts = def.name.split(/(\( [a-z0-9]+ \)|< [a-z0-9]+ >|\* [a-z0-9]+ \*)/);
      let argCounter = 0;
      return (
        <div className="flex items-center flex-wrap">
          {def.icon && <span className="mr-2 opacity-50">{def.icon}</span>}
          {parts.map((part, i) => {
            if (part.match(/\( [a-z0-9]+ \)|< [a-z0-9]+ >|\* [a-z0-9]+ \*/)) {
              const el = renderArg(block.args[argCounter], argCounter, i);
              argCounter++;
              return el;
            }
            return <span key={i} className="font-bold text-sm mx-0.5 pointer-events-none">{part.trim()}</span>;
          })}
        </div>
      );
    };

    return (
      <div 
        draggable={!isSetup} // SETUP ç¦æ­¢æ‹–æ›³
        onDragStart={(e) => !isSetup && handleDragStart(e, 'MOVE', { id: block.id, type: block.type })}
        onClick={(e) => e.stopPropagation()}
        className={`text-white relative group ${!isSetup ? 'cursor-grab active:cursor-grabbing' : 'cursor-default'} ${shapeClass} ${bgColor} p-2 shadow-md border-l-4 border-black/10 select-none`}
      >
        <div className="flex justify-between items-center">
          {renderTitle()}
          {isSetup && <Lock size={12} className="ml-2 text-white/50" />}
        </div>

        {(def.shape === SHAPES.C_BLOCK || def.isLoop) && (
          <div 
            className={`ml-4 pl-2 border-l-2 border-white/20 min-h-[40px] mt-1 rounded-l transition-colors ${dragOverId === `${block.id}-cont` ? 'bg-yellow-100/20' : 'bg-black/10'}`}
            onDragOver={(e) => handleDragOver(e, `${block.id}-cont`, 'CONTAINER')}
            onDrop={(e) => handleDrop(e, block.id, 'CONTAINER', { subType: 'children' })}
          >
            {block.children && block.children.map((child, idx) => (
               <BlockRenderer key={child.id} block={child} depth={depth + 1} />
            ))}
            {(!block.children || block.children.length === 0) && (
                <div className="text-white/20 text-xs py-2 italic text-center pointer-events-none">æ‹–æ›³ç©æœ¨è‡³æ­¤</div>
            )}
          </div>
        )}

        {def.hasElse && (
          <>
            <div className="text-xs font-bold px-1 py-1 border-t border-white/10 pointer-events-none">å¦å‰‡</div>
            <div 
                className={`ml-4 pl-2 border-l-2 border-white/20 min-h-[40px] bg-black/10 rounded-l transition-colors ${dragOverId === `${block.id}-else` ? 'bg-yellow-100/20' : ''}`}
                onDragOver={(e) => handleDragOver(e, `${block.id}-else`, 'CONTAINER')}
                onDrop={(e) => handleDrop(e, block.id, 'CONTAINER', { subType: 'else' })}
            >
              {block.elseChildren && block.elseChildren.map((child, idx) => (
                  <BlockRenderer key={child.id} block={child} />
              ))}
            </div>
          </>
        )}
      </div>
    );
  };

  return (
    <div className="flex h-screen bg-gray-900 text-gray-100 font-sans overflow-hidden select-none">
      
      {/* 1. å·¦å´å·¥å…·ç®± (Source) */}
      <div className="w-72 flex flex-col border-r border-gray-700 bg-gray-800 z-10 shadow-xl">
        <div className="p-3 bg-gray-900 font-bold flex items-center shadow text-yellow-400">
            <Cpu className="mr-2"/> å…ƒä»¶åº« (å¯æ‹–æ›³)
        </div>
        
        <div className="flex flex-wrap gap-1 p-2 bg-gray-800 border-b border-gray-700">
             {Object.keys(CATEGORIES).map(key => (
                 <button key={key} className={`flex items-center justify-center w-8 h-8 rounded ${CATEGORIES[key].color} text-white shadow hover:scale-110 transition-transform`} title={CATEGORIES[key].name}>
                     {CATEGORIES[key].icon}
                 </button>
             ))}
        </div>

        <div className="flex-1 overflow-y-auto p-3 space-y-4 custom-scrollbar" 
             onDragOver={(e) => handleDragOver(e, 'TRASH', 'TRASH')}
             onDrop={(e) => handleDrop(e, 'TRASH', 'TRASH')}>
            {Object.keys(CATEGORIES).map(catKey => (
                <div key={catKey}>
                    <h3 className="text-[10px] text-gray-500 mb-1 font-bold uppercase tracking-wider">{CATEGORIES[catKey].name}</h3>
                    <div className="space-y-2">
                        {/* é€™è£¡éæ¿¾æ‰ SETUPï¼Œä½¿å…¶ä¸é¡¯ç¤ºåœ¨å·¥å…·ç®± */}
                        {Object.keys(BLOCK_DEFS).filter(k => BLOCK_DEFS[k].cat === catKey && k !== 'SETUP').map(key => {
                            const b = BLOCK_DEFS[key];
                            return (
                                <div 
                                    key={key} 
                                    draggable
                                    onDragStart={(e) => handleDragStart(e, 'NEW', { defKey: key })}
                                    className={`cursor-grab active:cursor-grabbing px-3 py-2 rounded text-xs text-white shadow-sm hover:shadow-md transform hover:translate-x-1 transition-all ${CATEGORIES[catKey].color}`}
                                >
                                    {b.name}
                                </div>
                            );
                        })}
                        
                        {catKey === 'VAR' && (
                            <>
                                <button onClick={() => setShowVarModal(true)} className="w-full py-1 bg-gray-700 text-xs rounded border border-gray-600 mb-2">+ è®Šæ•¸</button>
                                {variables.map(v => (
                                    <div key={v} className="flex gap-1 mb-1">
                                        <div draggable onDragStart={(e) => handleDragStart(e, 'NEW', { defKey: 'VAR_GET', data: {varName: v, isVar: true, shape: SHAPES.REPORTER, cat: 'VAR', color: 'bg-orange-400', name: v} })} 
                                             className="cursor-grab px-3 py-1 bg-orange-400 rounded-full text-xs text-white shadow flex-1 text-center">{v}</div>
                                        <div draggable onDragStart={(e) => handleDragStart(e, 'NEW', { defKey: 'VAR_SET', data: {args: [v, 0], isVar: true, shape: SHAPES.STACK, cat: 'VAR', color: 'bg-orange-400', name: `è®Šæ•¸ ${v} è¨­ç‚º ( val )`} })}
                                             className="cursor-grab px-2 py-1 bg-orange-400 rounded text-xs text-white shadow">è¨­</div>
                                         <div draggable onDragStart={(e) => handleDragStart(e, 'NEW', { defKey: 'VAR_CHANGE', data: {args: [v, 1], isVar: true, shape: SHAPES.STACK, cat: 'VAR', color: 'bg-orange-400', name: `è®Šæ•¸ ${v} æ”¹è®Š ( val )`} })}
                                             className="cursor-grab px-2 py-1 bg-orange-400 rounded text-xs text-white shadow">æ”¹</div>
                                    </div>
                                ))}
                            </>
                        )}
                        {catKey === 'LIST' && <button onClick={() => setShowListModal(true)} className="w-full py-1 bg-gray-700 text-xs rounded border border-gray-600">+ æ¸…å–®</button>}
                    </div>
                </div>
            ))}
            
            <div className={`mt-8 border-2 border-dashed border-red-900/50 rounded-xl p-4 text-center text-red-500/50 transition-colors ${dragOverId === 'TRASH' ? 'bg-red-900/20 border-red-500 text-red-400' : ''}`}>
                <Trash2 className="mx-auto mb-2 pointer-events-none"/>
                <span className="text-xs pointer-events-none">æ‹–æ›³ç©æœ¨è‡³æ­¤åˆªé™¤</span>
            </div>
        </div>
      </div>

      {/* 2. ä¸­é–“å·¥ä½œå€ (Root Drop Zone) */}
      <div className="flex-1 flex flex-col bg-[#1e1e1e] relative overflow-hidden">
         <div className="h-10 bg-gray-800 border-b border-gray-700 flex items-center justify-between px-4">
             <div className="flex items-center text-gray-400 text-xs">
                 <MousePointer2 size={12} className="mr-1"/> æ”¯æ´æ‹–æ›³æ“ä½œ
             </div>
             {/* ä¿®æ­£æ¸…ç©ºé‚è¼¯ï¼šæ¢å¾©åˆ°åˆå§‹ç‹€æ…‹ */}
             <button onClick={() => setScript(INITIAL_SCRIPT)} className="text-red-400 hover:bg-red-900/50 p-1 rounded transition-colors"><Trash2 size={16}/></button>
         </div>

         <div 
            className={`flex-1 overflow-auto p-8 relative transition-colors ${dragOverId === 'ROOT' ? 'bg-white/5' : ''}`}
            style={{ backgroundImage: 'radial-gradient(#333 1px, transparent 1px)', backgroundSize: '20px 20px' }}
            onDragOver={(e) => handleDragOver(e, 'ROOT', 'ROOT')}
            onDrop={(e) => handleDrop(e, 'ROOT', 'ROOT')}
         >
             <div className="space-y-2 pb-32">
                 {script.map((block) => (
                     <BlockRenderer key={block.id} block={block} />
                 ))}
             </div>
         </div>
      </div>

      {/* 3. å³å´ä»£ç¢¼ */}
      <div className="w-80 bg-gray-950 border-l border-gray-800 flex flex-col z-10">
          <div className="h-10 bg-gray-900 border-b border-gray-800 flex items-center px-4 font-mono text-sm text-green-400">
              <Terminal size={14} className="mr-2"/> Generated C++
          </div>
          <div className="flex-1 overflow-auto p-4 font-mono text-xs text-green-300/80 whitespace-pre-wrap select-text custom-scrollbar">
              {generateCode()}
          </div>
          <button 
            onClick={() => { navigator.clipboard.writeText(generateCode()); alert('ä»£ç¢¼å·²è¤‡è£½'); }}
            className="m-4 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded font-bold text-xs transition-colors shadow-lg"
          >
            è¤‡è£½ç¨‹å¼ç¢¼
          </button>
      </div>

      {(showVarModal || showListModal) && (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm">
            <div className="bg-gray-800 p-5 rounded-lg shadow-2xl border border-gray-600 w-72 transform transition-all scale-100">
                <h3 className="text-white mb-3 font-bold text-lg">{showVarModal ? 'æ–°è®Šæ•¸åç¨±' : 'æ–°æ¸…å–®åç¨±'}</h3>
                <input autoFocus value={newItemName} onChange={e => setNewItemName(e.target.value)} className="w-full bg-gray-900 text-white p-2 rounded border border-gray-700 mb-4 focus:ring-2 focus:ring-blue-500 outline-none"/>
                <div className="flex justify-end gap-2">
                    <button onClick={() => { setShowVarModal(false); setShowListModal(false); }} className="px-4 py-2 text-gray-400 hover:bg-gray-700 rounded transition-colors text-sm">å–æ¶ˆ</button>
                    <button onClick={showVarModal ? createVariable : createList} className={`px-4 py-2 text-white rounded shadow transition-transform active:scale-95 text-sm ${showVarModal ? 'bg-orange-500 hover:bg-orange-600' : 'bg-red-500 hover:bg-red-600'}`}>å»ºç«‹</button>
                </div>
            </div>
        </div>
      )}
    </div>
  );
}
