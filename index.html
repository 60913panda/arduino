<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arduino 積木編輯器 V5.11 (Smooth Drag)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; background-color: #1e1e1e; }
        
        .custom-scrollbar::-webkit-scrollbar { width: 8px; height: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #1f2937; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #6b7280; }

        :root {
            --workspace-bg: #1e1e1e;
            --notch-size: 15px;
            --notch-height: 4px;
            --notch-left: 12px;
        }

        .block-base {
            position: relative;
            border-radius: 4px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2); 
            border: 1px solid rgba(0,0,0,0.1);
        }

        .has-notch-top { margin-top: 2px; }
        .has-notch-top::before {
            content: ''; position: absolute; top: -1px; left: var(--notch-left);
            width: var(--notch-size); height: var(--notch-height);
            background-color: var(--workspace-bg);
            border-bottom: 1px solid rgba(0,0,0,0.1);
            border-left: 1px solid rgba(0,0,0,0.1);
            border-right: 1px solid rgba(0,0,0,0.1);
            border-radius: 0 0 4px 4px; z-index: 2;
        }

        .has-bump-bottom { margin-bottom: 4px; }
        .has-bump-bottom::after {
            content: ''; position: absolute; bottom: -4px; left: var(--notch-left);
            width: var(--notch-size); height: var(--notch-height);
            background-color: inherit;
            border: 1px solid rgba(0,0,0,0.1); border-top: none;
            border-radius: 0 0 4px 4px; z-index: 1;
        }

        .block-hat { border-radius: 20px 20px 4px 4px; margin-top: 10px; }
        .block-cap { border-bottom: 2px solid rgba(0,0,0,0.2); margin-bottom: 4px; } 
        
        .c-interior {
            background-color: rgba(0,0,0,0.1); border-top: 1px solid rgba(0,0,0,0.1);
            min-height: 40px; padding-left: 10px; border-radius: 0 4px 4px 0;
            box-shadow: inset 0 2px 2px rgba(0,0,0,0.1);
            position: relative;
        }
        .c-interior::before {
            content: ''; position: absolute; top: 0; left: var(--notch-left);
            width: var(--notch-size); height: var(--notch-height);
            background-color: rgba(0,0,0,0.1);
            border-radius: 0 0 4px 4px;
        }

        .block-reporter { border-radius: 12px; padding: 4px 8px; display: inline-flex; align-items: center; margin: 0 4px; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.1); }
        .block-boolean { clip-path: polygon(10px 0, 100% 0, calc(100% - 10px) 50%, 100% 100%, 10px 100%, 0 50%); padding: 4px 12px; display: inline-flex; align-items: center; margin: 0 4px; }

        .bg-orange-500 { background-color: #ff8c1a; }
        .bg-yellow-500 { background-color: #ffbf00; color: #333; }
        .bg-blue-500 { background-color: #4c97ff; }
        .bg-purple-500 { background-color: #9966ff; }
        .bg-green-500 { background-color: #59c059; }
        .bg-red-500 { background-color: #ff6680; }

        .selected-block { box-shadow: 0 0 0 3px #fbbf24; z-index: 50; }
        
        /* 拖曳樣式：pointer-events: none 讓滑鼠可以穿透積木偵測到下方的放置區 */
        .dragging { opacity: 0.6; transform: scale(1.02); z-index: 100; pointer-events: none; }
        
        .drop-target { background-color: rgba(255, 255, 255, 0.1); outline: 2px dashed rgba(255, 255, 255, 0.5); border-radius: 4px; }
        .drop-target-invalid { cursor: not-allowed; }
        .drop-target-after { border-bottom: 4px solid #fbbf24 !important; margin-bottom: 4px; }
        
        .grid-bg {
            background-color: var(--workspace-bg);
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #context-menu {
            position: absolute; display: none; z-index: 100;
            background: #374151; border: 1px solid #4b5563; border-radius: 6px; box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .ctx-item { padding: 8px 16px; cursor: pointer; color: #e5e7eb; font-size: 13px; }
        .ctx-item:hover { background: #4b5563; }
        .ctx-divider { height: 1px; background: #4b5563; margin: 4px 0; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 h-screen flex overflow-hidden" onclick="hideContextMenu()">

    <!-- 左側工具箱 -->
    <div class="w-80 flex flex-col border-r border-gray-700 bg-gray-800 z-10 shadow-xl" id="toolbox">
        <div class="p-4 bg-gray-900 font-bold flex items-center shadow text-yellow-400 border-b border-gray-700">
            <i data-lucide="cpu" class="mr-2"></i> 積木工具箱
        </div>
        <div class="flex flex-wrap gap-1 p-2 bg-gray-800 border-b border-gray-700" id="category-tabs"></div>
        <div class="flex-1 overflow-y-auto p-3 space-y-6 custom-scrollbar relative" id="palette"></div>
        <div class="p-4 bg-red-900/20 border-t border-red-900/50 text-center text-red-400 text-xs transition-colors" id="trash-zone">
            <i data-lucide="trash-2" class="mx-auto mb-1"></i> 拖曳至此刪除
        </div>
    </div>

    <!-- 中間工作區 -->
    <div class="flex-1 flex flex-col bg-[#1e1e1e] relative overflow-hidden">
        <div class="h-12 bg-gray-800 border-b border-gray-700 flex items-center justify-between px-4 shadow-md z-20">
            <div class="flex items-center text-gray-400 text-sm">
                <i data-lucide="mouse-pointer-2" class="mr-2 w-4"></i> 自動生成 pinMode | 凹凸防呆
            </div>
            <div class="flex space-x-2">
                <button onclick="deleteSelected()" class="flex items-center text-red-400 hover:bg-red-900/50 px-3 py-1 rounded transition-colors text-sm">
                    <i data-lucide="trash" class="w-4 h-4 mr-1"></i> 刪除
                </button>
                <button onclick="resetWorkspace()" class="flex items-center text-gray-300 hover:bg-gray-700 px-3 py-1 rounded transition-colors text-sm">
                    <i data-lucide="rotate-ccw" class="mr-1 w-4"></i> 重置
                </button>
            </div>
        </div>
        <div id="workspace" class="flex-1 overflow-auto p-8 relative grid-bg" onclick="clearSelection()"></div>
    </div>

    <!-- 右側預覽 -->
    <div class="w-96 bg-gray-950 border-l border-gray-800 flex flex-col z-10 shadow-xl">
        <div class="h-12 bg-gray-900 border-b border-gray-800 flex items-center px-4 font-mono text-sm text-green-400">
            <i data-lucide="terminal" class="mr-2 w-4"></i> C++ Code
        </div>
        <div class="flex-1 overflow-auto p-4 font-mono text-xs text-green-300/90 whitespace-pre-wrap select-text custom-scrollbar bg-[#111]" id="code-preview"></div>
        <div class="p-4 border-t border-gray-800 bg-gray-900">
            <button onclick="copyCode()" class="w-full py-2 bg-blue-600 hover:bg-blue-500 text-white rounded font-bold text-sm transition-colors shadow-lg flex items-center justify-center">
                <i data-lucide="copy" class="mr-2 w-4"></i> 複製程式碼
            </button>
        </div>
    </div>

    <div id="context-menu">
        <div class="ctx-item" onclick="duplicateSelected()">複製 (Ctrl+C)</div>
        <div class="ctx-divider"></div>
        <div class="ctx-item text-red-400" onclick="deleteSelected()">刪除 (Del)</div>
    </div>
    <div id="modal-overlay" class="fixed inset-0 bg-black/70 hidden flex items-center justify-center z-50 backdrop-blur-sm">
        <div class="bg-gray-800 p-6 rounded-lg shadow-2xl border border-gray-600 w-80 transform transition-all">
            <h3 id="modal-title" class="text-white mb-4 font-bold text-lg">新建</h3>
            <input type="text" id="modal-input" class="w-full bg-gray-900 text-white p-2 rounded border border-gray-700 mb-6 focus:ring-2 focus:ring-blue-500 outline-none">
            <div class="flex justify-end gap-2">
                <button onclick="closeModal()" class="px-4 py-2 text-gray-400 hover:bg-gray-700 rounded transition-colors text-sm">取消</button>
                <button id="modal-confirm" class="px-4 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded shadow text-sm">確定</button>
            </div>
        </div>
    </div>

<script>
    const SHAPES = { HAT: 'HAT', STACK: 'STACK', C_BLOCK: 'C', CAP: 'CAP', REPORTER: 'VAL', BOOLEAN: 'BOOL' };
    
    const BLOCK_DEFS = {
        SETUP: { type: 'SETUP', cat: 'EVENT', name: '當 Arduino 開啟', shape: SHAPES.HAT },
        WAIT: { type: 'WAIT', cat: 'CONTROL', name: '等待 ( time ) 毫秒', args: [{type: 'NUM', default: 1000}], shape: SHAPES.STACK },
        WAIT_UNTIL: { type: 'WAIT_UNTIL', cat: 'CONTROL', name: '等待直到 < cond >', args: [{type: 'BOOL', default: false}], shape: SHAPES.STACK },
        FOREVER: { type: 'FOREVER', cat: 'LOOP', name: '重複無限次', shape: SHAPES.CAP, isLoop: true },
        REPEAT: { type: 'REPEAT', cat: 'LOOP', name: '重複 ( times ) 次', args: [{type: 'NUM', default: 10}], shape: SHAPES.C_BLOCK },
        REPEAT_UNTIL: { type: 'REPEAT_UNTIL', cat: 'LOOP', name: '重複直到 < cond >', args: [{type: 'BOOL', default: false}], shape: SHAPES.C_BLOCK },
        IF: { type: 'IF', cat: 'LOGIC', name: '如果 < cond > 那麼', args: [{type: 'BOOL', default: false}], shape: SHAPES.C_BLOCK },
        IF_ELSE: { type: 'IF_ELSE', cat: 'LOGIC', name: '如果 < cond > 那麼...否則', args: [{type: 'BOOL', default: false}], shape: SHAPES.C_BLOCK, hasElse: true },
        COMPARE: { type: 'COMPARE', cat: 'LOGIC', name: '( a ) * op * ( b )', args: [{type: 'NUM', default: 0}, {type: 'MENU', options: ['==','!=','>','<','>=','<=']}, {type: 'NUM', default: 0}], shape: SHAPES.BOOLEAN },
        NUMBER: { type: 'NUMBER', cat: 'MATH', name: '( val )', args: [{type: 'NUM', default: 0}], shape: SHAPES.REPORTER },
        MATH_OP: { type: 'MATH_OP', cat: 'MATH', name: '( a ) * op * ( b )', args: [{type: 'NUM', default: 0}, {type: 'MENU', options: ['+','-','*','/']}, {type: 'NUM', default: 0}], shape: SHAPES.REPORTER },
        RANDOM: { type: 'RANDOM', cat: 'MATH', name: '隨機取數 ( min ) 到 ( max )', args: [{type: 'NUM', default: 1}, {type: 'NUM', default: 10}], shape: SHAPES.REPORTER },
        VAR_GET: { type: 'VAR_GET', cat: 'VAR', name: 'varName', isVar: true, shape: SHAPES.REPORTER },
        VAR_SET: { type: 'VAR_SET', cat: 'VAR', name: '變數 * var * 設為 ( val )', args: [{type: 'VAR_MENU'}, {type: 'NUM', default: 0}], shape: SHAPES.STACK },
        VAR_CHANGE: { type: 'VAR_CHANGE', cat: 'VAR', name: '變數 * var * 改變 ( val )', args: [{type: 'VAR_MENU'}, {type: 'NUM', default: 1}], shape: SHAPES.STACK },
        LIST_ADD: { type: 'LIST_ADD', cat: 'LIST', name: '添加 ( val ) 到 * list *', args: [{type: 'NUM', default: 0}, {type: 'LIST_MENU'}], shape: SHAPES.STACK },
        LIST_DEL_ALL: { type: 'LIST_DEL_ALL', cat: 'LIST', name: '刪除 * list * 的所有項目', args: [{type: 'LIST_MENU'}], shape: SHAPES.STACK },
        LIST_ITEM: { type: 'LIST_ITEM', cat: 'LIST', name: '* list * 的第 ( idx ) 項', args: [{type: 'LIST_MENU'}, {type: 'NUM', default: 0}], shape: SHAPES.REPORTER },
        LED_SET: { type: 'LED_SET', cat: 'IO', name: '數位寫入 Pin ( pin ) 為 * status *', args: [{type: 'NUM', default: 13}, {type: 'MENU', options: ['HIGH', 'LOW']}], shape: SHAPES.STACK },
        DIGITAL_READ: { type: 'DIGITAL_READ', cat: 'IO', name: '讀取數位腳位 ( pin )', args: [{type: 'NUM', default: 2}], shape: SHAPES.REPORTER },
    };

    const CATEGORIES = {
        EVENT: { name: '事件', color: 'bg-yellow-500', icon: 'play-circle' },
        CONTROL: { name: '控制', color: 'bg-orange-500', icon: 'settings' },
        LOOP: { name: '迴圈', color: 'bg-green-500', icon: 'refresh-cw' },
        LOGIC: { name: '邏輯', color: 'bg-blue-500', icon: 'git-branch' },
        MATH: { name: '運算', color: 'bg-green-400', icon: 'plus' },
        VAR: { name: '變數', color: 'bg-orange-400', icon: 'type' },
        LIST: { name: '清單', color: 'bg-red-500', icon: 'list' },
        IO: { name: '硬體', color: 'bg-purple-500', icon: 'cpu' },
    };

    let state = { script: [], variables: [], lists: [] };
    let dragData = null; 
    let selectedBlockIds = new Set();

    function init() {
        setupEventListeners();
        resetWorkspace();
        renderSidebar();
        lucide.createIcons();
        document.addEventListener('keydown', handleKeyDown);
    }

    function setupEventListeners() {
        const trash = document.getElementById('toolbox');
        const trashZone = document.getElementById('trash-zone');
        if (trash && trashZone) {
            trash.ondragover = (e) => { e.preventDefault(); trashZone.classList.add('bg-red-800'); };
            trash.ondragleave = () => { trashZone.classList.remove('bg-red-800'); };
            trash.ondrop = (e) => {
                e.preventDefault();
                trashZone.classList.remove('bg-red-800');
                if (dragData && dragData.type === 'MOVE') {
                    const block = findBlock(dragData.id);
                    if (block && !block.locked) {
                        findAndRemoveBlock(dragData.id);
                        renderWorkspace();
                        updateCode();
                    }
                }
            };
        }
        const ws = document.getElementById('workspace');
        if (ws) {
            ws.ondragover = (e) => { 
                e.preventDefault();
                if (dragData) {
                    const type = dragData.defKey || findBlockType(dragData.id);
                    if (!type || !BLOCK_DEFS[type]) return;

                    const def = BLOCK_DEFS[type];
                    let isValid = true;
                    if (def.shape === SHAPES.REPORTER || def.shape === SHAPES.BOOLEAN) isValid = false;
                    
                    if (state.script.length > 0) {
                        const lastBlock = state.script[state.script.length - 1];
                        const lastDef = BLOCK_DEFS[lastBlock.type];
                        if (lastDef && lastDef.shape === SHAPES.CAP) {
                            if (def.shape !== SHAPES.HAT) isValid = false;
                        }
                    }

                    if (isValid) ws.classList.add('drop-target');
                    else ws.classList.remove('drop-target');
                }
            };
            ws.ondragleave = () => ws.classList.remove('drop-target');
            ws.ondrop = (e) => {
                e.preventDefault();
                ws.classList.remove('drop-target');
                if (dragData) {
                    const type = dragData.defKey || findBlockType(dragData.id);
                    if (!type || !BLOCK_DEFS[type]) return;

                    const def = BLOCK_DEFS[type];
                    
                    let isValid = true;
                    if (def.shape === SHAPES.REPORTER || def.shape === SHAPES.BOOLEAN) isValid = false;
                    if (state.script.length > 0) {
                        const lastBlock = state.script[state.script.length - 1];
                        const lastDef = BLOCK_DEFS[lastBlock.type];
                        if (lastDef && lastDef.shape === SHAPES.CAP) {
                             if (def.shape !== SHAPES.HAT) isValid = false;
                        }
                    }

                    if (isValid) handleDrop(dragData, state.script, null, 'APPEND');
                }
            };
        }
    }

    function resetWorkspace() {
        state.script = [{ id: 'root-setup', type: 'SETUP', args: [], children: [], elseChildren: [], locked: true }];
        renderWorkspace();
        updateCode();
    }

    function uid() { return Math.random().toString(36).substr(2, 9); }

    function renderSidebar() {
        const tabs = document.getElementById('category-tabs');
        const palette = document.getElementById('palette');
        tabs.innerHTML = ''; palette.innerHTML = '';

        Object.entries(CATEGORIES).forEach(([key, cat]) => {
            const btn = document.createElement('button');
            btn.className = `flex items-center px-2 py-1 text-xs rounded ${cat.color} text-white shadow hover:opacity-80`;
            btn.innerHTML = `<i data-lucide="${cat.icon}" class="w-3 h-3 mr-1"></i> ${cat.name}`;
            btn.onclick = () => document.getElementById(`cat-${key}`).scrollIntoView({behavior: 'smooth'});
            tabs.appendChild(btn);
        });

        Object.keys(CATEGORIES).forEach(catKey => {
            const section = document.createElement('div');
            section.id = `cat-${catKey}`;
            section.className = 'mb-6';
            section.innerHTML = `<h3 class="text-[10px] text-gray-500 mb-2 font-bold uppercase pl-1">${CATEGORIES[catKey].name}</h3>`;

            if (catKey === 'VAR') {
                section.appendChild(createBtn('+ 建立變數', () => openModal('VAR')));
                state.variables.forEach(v => section.appendChild(createSidebarBlock({ type: 'VAR_GET', data: { varName: v, name: v } }, CATEGORIES.VAR.color)));
            }
            if (catKey === 'LIST') {
                section.appendChild(createBtn('+ 建立清單', () => openModal('LIST')));
                state.lists.forEach(l => {
                    const div = document.createElement('div');
                    div.className = `px-3 py-1 mb-1 rounded-full text-xs text-white shadow text-center bg-red-500 border border-white/20 select-none`;
                    div.innerText = l;
                    section.appendChild(div);
                });
            }

            Object.keys(BLOCK_DEFS).filter(k => BLOCK_DEFS[k].cat === catKey).forEach(key => {
                const def = BLOCK_DEFS[key];
                if ((catKey === 'VAR' && def.isVar) || (catKey === 'LIST' && def.type === 'LIST_ITEM')) return;
                section.appendChild(createSidebarBlock({ type: key }, CATEGORIES[catKey].color));
            });
            palette.appendChild(section);
        });
        lucide.createIcons();
    }

    function createBtn(text, onClick) {
        const btn = document.createElement('button');
        btn.className = 'w-full py-1 bg-gray-700 text-xs rounded border border-gray-600 mb-2 text-gray-300 hover:bg-gray-600';
        btn.innerText = text;
        btn.onclick = onClick;
        return btn;
    }

    function createSidebarBlock(info, colorClass) {
        const def = BLOCK_DEFS[info.type];
        const displayName = (info.data && info.data.name) ? info.data.name : def.name;
        const el = document.createElement('div');
        let shape = 'rounded';
        if (def.shape === SHAPES.REPORTER) shape = 'rounded-full px-3';
        if (def.shape === SHAPES.BOOLEAN) shape = 'clip-hex px-3';
        
        el.className = `mb-2 px-3 py-2 text-xs text-white shadow-sm hover:shadow-md cursor-grab active:cursor-grabbing transition-transform hover:translate-x-1 ${colorClass} ${shape} truncate`;
        el.innerText = displayName;
        el.draggable = true;
        el.ondragstart = (e) => {
            e.stopPropagation();
            dragData = { type: 'NEW', defKey: info.type, data: info.data || {} };
            e.dataTransfer.effectAllowed = 'copy';
        };
        return el;
    }

    function renderWorkspace() {
        const ws = document.getElementById('workspace');
        ws.innerHTML = '';
        state.script.forEach(block => ws.appendChild(createBlockElement(block, state.script)));
        lucide.createIcons();
    }

    function createBlockElement(block, parentList) {
        const def = BLOCK_DEFS[block.type] || { ...block, shape: SHAPES.STACK, color: 'bg-gray-500' };
        const cat = CATEGORIES[def.cat] || { color: 'bg-gray-500' };
        const bgColor = def.color || cat.color;
        
        const el = document.createElement('div');
        let classes = `block-base text-white relative group select-none p-2 ${bgColor} `;
        
        if (def.shape === SHAPES.HAT) classes += 'block-hat has-bump-bottom ';
        else if (def.shape === SHAPES.CAP) classes += 'block-cap has-notch-top '; 
        else if (def.shape === SHAPES.STACK || def.shape === SHAPES.C_BLOCK) classes += 'block-stack has-notch-top has-bump-bottom ';
        else if (def.shape === SHAPES.REPORTER) classes = `text-white relative group select-none block-reporter shadow-md ${bgColor} `;
        else if (def.shape === SHAPES.BOOLEAN) classes = `text-white relative group select-none block-boolean shadow-md ${bgColor} `;

        if (selectedBlockIds.has(block.id)) classes += 'selected-block ';

        el.className = classes;
        
        if (block.locked) {
            el.draggable = false;
            el.style.cursor = 'default';
        } else {
            el.draggable = true;
            el.onmousedown = (e) => {
                e.stopPropagation();
                if (e.button === 2) { showContextMenu(e, block.id); return; }
                if (e.ctrlKey || e.metaKey) toggleSelection(block.id);
                else if (!selectedBlockIds.has(block.id)) { clearSelection(); selectBlock(block.id); }
            };
            el.ondragstart = (e) => {
                e.stopPropagation();
                dragData = { type: 'MOVE', id: block.id, parentList: parentList };
                e.dataTransfer.effectAllowed = 'move';
                // [Fix] 延遲添加樣式，避免瀏覽器誤判拖曳元素消失
                setTimeout(() => el.classList.add('dragging'), 0);
            };
            el.ondragend = () => { el.classList.remove('dragging'); dragData = null; };
        }

        // 允許拖曳到積木上進行插入
        if (def.shape === SHAPES.STACK || def.shape === SHAPES.C_BLOCK || def.shape === SHAPES.CAP) {
            el.ondragover = (e) => {
                e.preventDefault();
                if (dragData) {
                    const type = dragData.defKey || findBlockType(dragData.id);
                    if (!type || !BLOCK_DEFS[type]) return;
                    const dragDef = BLOCK_DEFS[type];
                    
                    if (dragDef.shape === SHAPES.REPORTER || dragDef.shape === SHAPES.BOOLEAN) return;
                    if (dragDef.shape === SHAPES.HAT) return; 
                    if (dragData.id === block.id) return; 

                    e.stopPropagation(); 
                    el.classList.add('drop-target-after');
                }
            };
            el.ondragleave = () => el.classList.remove('drop-target-after');
            el.ondrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                el.classList.remove('drop-target-after');
                if (dragData) {
                    const idx = parentList.indexOf(block);
                    if (idx !== -1) {
                        handleDrop(dragData, parentList, idx + 1, 'INSERT');
                    }
                }
            };
        }

        const header = document.createElement('div');
        header.className = 'flex items-center flex-wrap gap-1 pointer-events-none';
        
        const parts = def.name.split(/(\( [a-z0-9]+ \)|< [a-z0-9]+ >|\* [a-z0-9]+ \*)/);
        let argIdx = 0;

        if (block.type === 'VAR_GET') header.innerText = block.varName;
        else {
            parts.forEach(part => {
                if (part.match(/\( [a-z0-9]+ \)|< [a-z0-9]+ >|\* [a-z0-9]+ \*/)) {
                    header.appendChild(createArgElement(block, argIdx, def.args[argIdx]));
                    argIdx++;
                } else {
                    const span = document.createElement('span');
                    span.className = 'font-bold text-sm mx-0.5';
                    span.innerText = part.trim();
                    header.appendChild(span);
                }
            });
        }
        
        if (block.locked) {
            header.innerHTML += `<i data-lucide="lock" class="w-3 h-3 ml-2 opacity-50"></i>`;
        }
        
        el.appendChild(header);

        if (def.shape === SHAPES.C_BLOCK || def.isLoop) {
            const container = document.createElement('div');
            container.className = 'c-interior mt-1 transition-colors';
            setupDropZone(container, (dropped) => moveBlock(dropped, block.children), block.children);
            block.children.forEach(child => container.appendChild(createBlockElement(child, block.children)));
            el.appendChild(container);
        }

        if (def.hasElse) {
            const elseLabel = document.createElement('div');
            elseLabel.className = 'text-xs font-bold px-1 py-1 border-t border-white/10 pointer-events-none';
            elseLabel.innerText = '否則';
            el.appendChild(elseLabel);
            const elseContainer = document.createElement('div');
            elseContainer.className = 'c-interior transition-colors';
            setupDropZone(elseContainer, (dropped) => moveBlock(dropped, block.elseChildren), block.elseChildren);
            block.elseChildren.forEach(child => elseContainer.appendChild(createBlockElement(child, block.elseChildren)));
            el.appendChild(elseContainer);
        }

        return el;
    }

    function createArgElement(block, argIdx, argDef) {
        const wrapper = document.createElement('div');
        wrapper.className = 'pointer-events-auto inline-block align-middle';
        const val = block.args[argIdx];

        if (typeof val === 'object' && val.id) {
            const argBlock = createBlockElement(val, block.args);
            argBlock.ondragstart = (e) => {
                e.stopPropagation();
                dragData = { type: 'MOVE', id: val.id, sourceArgs: block.args, sourceIdx: argIdx };
                e.dataTransfer.effectAllowed = 'move';
                // [Fix] 參數內的積木也需要延遲添加樣式
                setTimeout(() => argBlock.classList.add('dragging'), 0);
            };
            argBlock.ondragend = () => { argBlock.classList.remove('dragging'); dragData = null; };
            wrapper.appendChild(argBlock);
            return wrapper;
        }

        if (['MENU', 'VAR_MENU', 'LIST_MENU'].includes(argDef.type)) {
            const select = document.createElement('select');
            const bgClass = argDef.type === 'LIST_MENU' ? 'bg-red-100' : 'bg-white/90';
            select.className = `text-black text-xs px-1 py-0.5 rounded mx-1 border-none outline-none cursor-pointer ${bgClass}`;
            let options = argDef.options || [];
            if (argDef.type === 'VAR_MENU') options = state.variables.length ? state.variables : ['無變數'];
            if (argDef.type === 'LIST_MENU') options = state.lists.length ? state.lists : ['無清單'];

            options.forEach(opt => {
                const o = document.createElement('option');
                o.value = opt;
                o.innerText = opt;
                if (opt === val) o.selected = true;
                select.appendChild(o);
            });
            select.onchange = (e) => { block.args[argIdx] = e.target.value; updateCode(); };
            wrapper.appendChild(select);
            return wrapper;
        }

        const slot = document.createElement('div');
        const shapeClass = argDef.type === 'BOOL' ? 'clip-hex px-3' : 'rounded-full px-2';
        slot.className = `inline-flex items-center justify-center min-w-[30px] h-[24px] mx-1 text-xs transition-all bg-black/20 hover:bg-black/30 ${shapeClass}`;
        
        slot.ondragover = (e) => { e.preventDefault(); slot.classList.add('bg-yellow-100/50'); };
        slot.ondragleave = () => slot.classList.remove('bg-yellow-100/50');
        slot.ondrop = (e) => {
            e.preventDefault();
            e.stopPropagation();
            slot.classList.remove('bg-yellow-100/50');
            if (dragData) {
                const def = BLOCK_DEFS[dragData.defKey || findBlockType(dragData.id)];
                if (!def) return;

                const compatible = (argDef.type === 'NUM' && def.shape === SHAPES.REPORTER) ||
                                   (argDef.type === 'BOOL' && def.shape === SHAPES.BOOLEAN) ||
                                   (argDef.type === 'ANY' && def.shape === SHAPES.REPORTER);
                if (compatible) handleDrop(dragData, block.args, argIdx, 'REPLACE');
            }
        };

        if (argDef.type === 'NUM' || argDef.type === 'ANY') {
            const input = document.createElement('input');
            input.type = 'text'; input.value = val;
            input.className = 'bg-transparent text-white text-center w-12 outline-none';
            input.onchange = (e) => { block.args[argIdx] = e.target.value; updateCode(); };
            input.onclick = (e) => e.stopPropagation();
            slot.appendChild(input);
        } else {
            slot.innerText = '< >';
            slot.className += ' text-white/50 text-[10px]';
        }
        wrapper.appendChild(slot);
        return wrapper;
    }

    function setupDropZone(el, onDropSuccess, targetList) {
        el.ondragover = (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (dragData) {
                const type = dragData.defKey || findBlockType(dragData.id);
                if (!type || !BLOCK_DEFS[type]) return;
                const def = BLOCK_DEFS[type];
                
                let isValid = true;
                if (def.shape === SHAPES.HAT) isValid = false;
                if (def.shape === SHAPES.REPORTER || def.shape === SHAPES.BOOLEAN) isValid = false;

                if (targetList && targetList.length > 0) {
                    const lastBlock = targetList[targetList.length - 1];
                    const lastDef = BLOCK_DEFS[lastBlock.type];
                    if (lastDef && lastDef.shape === SHAPES.CAP) isValid = false;
                }

                if (isValid) el.classList.add('drop-target');
                else el.classList.add('drop-target-invalid'); 
            }
        };
        el.ondragleave = (e) => { 
            e.preventDefault(); 
            el.classList.remove('drop-target'); 
            el.classList.remove('drop-target-invalid'); 
        };
        el.ondrop = (e) => {
            e.preventDefault();
            e.stopPropagation();
            const wasValid = el.classList.contains('drop-target');
            el.classList.remove('drop-target');
            el.classList.remove('drop-target-invalid');
            if (wasValid && dragData) {
                handleDrop(dragData, null, null, 'APPEND', onDropSuccess);
            }
        };
    }

    function handleDrop(data, targetContainer, targetIndex, mode = 'APPEND', customAction = null) {
        let block;
        if (data.type === 'NEW') {
            const def = BLOCK_DEFS[data.defKey];
            block = {
                id: uid(), type: data.defKey,
                args: def.args ? def.args.map(a => a.default) : [],
                children: [], elseChildren: [], ...data.data
            };
        } else {
            block = findAndRemoveBlock(data.id);
            if (!block) return;
        }

        // [Fix] Safety check
        if (!targetContainer && mode !== 'APPEND' && !customAction) targetContainer = state.script;

        if (mode === 'REPLACE') {
            targetContainer[targetIndex] = block;
        } else if (mode === 'INSERT') {
            targetContainer.splice(targetIndex, 0, block);
        } else if (mode === 'APPEND') {
            if (customAction) customAction(block);
            else if (targetContainer) targetContainer.push(block);
        }

        renderWorkspace();
        updateCode();
    }

    function moveBlock(block, list) { list.push(block); }

    function findAndRemoveBlock(id, list = state.script) {
        const idx = list.findIndex(b => b.id === id);
        if (idx !== -1) {
            if (list[idx].locked) return null;
            return list.splice(idx, 1)[0];
        }
        for (let b of list) {
            if (b.children) { const res = findAndRemoveBlock(id, b.children); if (res) return res; }
            if (b.elseChildren) { const res = findAndRemoveBlock(id, b.elseChildren); if (res) return res; }
            if (b.args) {
                for (let i=0; i<b.args.length; i++) {
                    const arg = b.args[i];
                    if (typeof arg === 'object' && arg.id) {
                        if (arg.id === id) {
                             const def = BLOCK_DEFS[b.type];
                             b.args[i] = def.args[i].default;
                             return arg;
                        }
                        const res = findAndRemoveBlockInBlock(id, arg);
                        if (res) return res;
                    }
                }
            }
        }
        return null;
    }

    function findAndRemoveBlockInBlock(id, block) {
         if (block.children) { const res = findAndRemoveBlock(id, block.children); if (res) return res; }
         if (block.elseChildren) { const res = findAndRemoveBlock(id, block.elseChildren); if (res) return res; }
         if (block.args) {
            for (let i=0; i<block.args.length; i++) {
                const arg = block.args[i];
                if (typeof arg === 'object' && arg.id) {
                    if (arg.id === id) {
                        const def = BLOCK_DEFS[block.type];
                        block.args[i] = def.args[i].default;
                        return arg;
                    }
                    const res = findAndRemoveBlockInBlock(id, arg);
                    if (res) return res;
                }
            }
         }
         return null;
    }
    
    function findBlock(id, list = state.script) {
        for (let b of list) {
            if (b.id === id) return b;
            let found = (b.children && findBlock(id, b.children)) || (b.elseChildren && findBlock(id, b.elseChildren));
            if (found) return found;
            if (b.args) {
                for (let arg of b.args) {
                    if (typeof arg === 'object' && arg.id) {
                        if (arg.id === id) return arg;
                        found = findBlock(id, [arg]); 
                        if (found) return found;
                    }
                }
            }
        }
        return null;
    }

    function findBlockType(id, list = state.script) {
        for (let b of list) {
            if (b.id === id) return b.type;
            let found = (b.children && findBlockType(id, b.children)) || (b.elseChildren && findBlockType(id, b.elseChildren));
            if (found) return found;
            if (b.args) {
                for (let arg of b.args) {
                    if (typeof arg === 'object' && arg.id) {
                        if (arg.id === id) return arg.type;
                        found = findBlockType(id, [arg]);
                        if (found) return found;
                    }
                }
            }
        }
        return null;
    }

    function selectBlock(id) { selectedBlockIds.add(id); renderWorkspace(); }
    function toggleSelection(id) { if (selectedBlockIds.has(id)) selectedBlockIds.delete(id); else selectedBlockIds.add(id); renderWorkspace(); }
    function clearSelection() { selectedBlockIds.clear(); renderWorkspace(); hideContextMenu(); }
    function deleteSelected() { 
        selectedBlockIds.forEach(id => {
            const block = findBlock(id);
            if (block && !block.locked) findAndRemoveBlock(id);
        }); 
        selectedBlockIds.clear(); renderWorkspace(); updateCode(); hideContextMenu(); 
    }
    function duplicateSelected() { alert('Lite版: 請拖曳新積木'); hideContextMenu(); }
    
    function handleKeyDown(e) {
        if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return;
        if (e.key === 'Delete') deleteSelected();
    }

    function showContextMenu(e, id) {
        e.preventDefault();
        const block = findBlock(id);
        if (block && block.locked) return;

        if (!selectedBlockIds.has(id)) { clearSelection(); selectBlock(id); }
        const menu = document.getElementById('context-menu');
        menu.style.display = 'block';
        menu.style.left = e.pageX + 'px';
        menu.style.top = e.pageY + 'px';
    }
    function hideContextMenu() { document.getElementById('context-menu').style.display = 'none'; }

    function updateCode() {
        let globalVars = '';
        let setupCode = '';
        let loopCode = '';
        let functions = '';
        
        let usedPins = new Map(); 

        state.variables.forEach(v => { globalVars += `float ${v} = 0;\n`; });
        state.lists.forEach(l => { globalVars += `float ${l}[100];\nint ${l}_len = 0;\n`; });
        if (state.lists.length) {
            functions += `void list_add(float* l, int* len, float v) { if(*len<100) l[(*len)++] = v; }\nvoid list_del_all(int* len) { *len=0; }\n`;
        }

        const scanBlocks = (arr) => {
            arr.forEach(b => {
                const args = b.args;
                if (b.type === 'LED_SET') usedPins.set(args[0], 'OUTPUT');
                if (b.type === 'DIGITAL_READ') usedPins.set(args[0], 'INPUT');
                if (b.children) scanBlocks(b.children);
                if (b.elseChildren) scanBlocks(b.elseChildren);
                if (b.args) {
                    b.args.forEach(arg => { if (typeof arg === 'object' && arg.id) scanBlocks([arg]); });
                }
            });
        };
        scanBlocks(state.script);

        usedPins.forEach((mode, pin) => {
            setupCode += `  pinMode(${pin}, ${mode});\n`;
        });

        const parseBlock = (b) => {
            const args = (b.args || []).map(a => (typeof a === 'object' && a.id) ? parseBlock(a) : a);
            switch(b.type) {
                case 'SETUP': return ''; 
                case 'WAIT': return `delay(${args[0]});\n`;
                case 'WAIT_UNTIL': return `while(!(${args[0]})) { delay(10); }\n`;
                case 'FOREVER': return `// Loop\n${parseChildren(b.children)}`;
                case 'REPEAT': return `for(int i=0; i<${args[0]}; i++) {\n${parseChildren(b.children)}}\n`;
                case 'REPEAT_UNTIL': return `while(!(${args[0]})) {\n${parseChildren(b.children)}}\n`;
                case 'IF': return `if(${args[0]}) {\n${parseChildren(b.children)}}\n`;
                case 'IF_ELSE': return `if(${args[0]}) {\n${parseChildren(b.children)}} else {\n${parseChildren(b.elseChildren)}}\n`;
                case 'NUMBER': return `${args[0]}`;
                case 'COMPARE': return `(${args[0]} ${args[1]} ${args[2]})`;
                case 'VAR_GET': return `${b.varName || b.args[0]}`;
                case 'VAR_SET': return `${args[0]} = ${args[1]};\n`;
                case 'VAR_CHANGE': return `${args[0]} += ${args[1]};\n`;
                case 'LED_SET': return `digitalWrite(${args[0]}, ${args[1]==='亮'?'HIGH':'LOW'});\n`;
                case 'DIGITAL_READ': return `digitalRead(${args[0]})`;
                default: return `// ${b.type}\n`;
            }
        };
        const parseChildren = (arr) => arr ? arr.map(b => parseBlock(b)).join('') : '';

        state.script.forEach(b => {
            if (b.type === 'FOREVER') loopCode += parseChildren(b.children);
            else if (b.type !== 'SETUP') setupCode += parseBlock(b);
        });

        const full = `${globalVars}\n${functions}\nvoid setup() {\n  Serial.begin(9600);\n${setupCode}}\n\nvoid loop() {\n${loopCode}}`;
        document.getElementById('code-preview').innerText = full;
    }

    let modalType = '';
    function openModal(type) {
        modalType = type;
        document.getElementById('modal-title').innerText = type==='VAR'?'新變數':'新清單';
        document.getElementById('modal-input').value = '';
        document.getElementById('modal-overlay').classList.remove('hidden');
    }
    function closeModal() { document.getElementById('modal-overlay').classList.add('hidden'); }
    document.getElementById('modal-confirm').onclick = () => {
        const name = document.getElementById('modal-input').value.trim();
        if (name) {
            if (modalType === 'VAR') state.variables.push(name);
            else state.lists.push(name);
            renderSidebar();
        }
        closeModal();
    };

    function copyCode() {
        navigator.clipboard.writeText(document.getElementById('code-preview').innerText);
        alert('已複製');
    }

    init();
</script>
</body>
</html>
